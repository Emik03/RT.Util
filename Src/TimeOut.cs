/// Utils.cs  -  utility functions and classes

using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Threading;
using System.Windows.Forms;
using System.Diagnostics;

namespace RT.Util
{
    /// <summary>
    /// This class offers some generic static functions which are hard to categorize
    /// under any more specific classes.
    /// </summary>
    public static class Ut
    {
        /// <summary>
        /// An application-wide random number generator - use this generator if all you
        /// need is a random number. Create a new generator only if you really need to.
        /// </summary>
        public static Random Rnd = new Random();

        /// <summary>
        /// Stores a copy of the value generated by AppDir. This way AppDir
        /// only needs to generate it once.
        /// </summary>
        private static string CachedAppDir = "";

        /// <summary>
        /// Returns the application directory with a directory separator char
        /// at the end. The expression 'Ra.AppDir + "FileName"' yields a valid
        /// fully qualified file name. Supports network paths.
        /// </summary>
        public static string AppDir
        {
            get
            {
                if (CachedAppDir == "")
                {
                    CachedAppDir = Application.ExecutablePath;
                    CachedAppDir = CachedAppDir.Remove(
                        CachedAppDir.LastIndexOf(System.IO.Path.DirectorySeparatorChar) + 1);
                }
                return CachedAppDir;
            }
        }

        /// <summary>
        /// Converts file size in bytes to a string in bytes, kbytes, Mbytes
        /// or Gbytes accordingly.
        /// </summary>
        /// <param name="size">Size in bytes</param>
        /// <returns>Converted string</returns>
        public static string SizeToString(long size)
        {
            if (size == 0)
            {
                return "0";
            }
            else if (size < 1024)
            {
                return size.ToString("#,###");
            }
            else if (size < 1024 * 1024)
            {
                return (size / 1024d).ToString("#,###.## k");
            }
            else if (size < 1024 * 1024 * 1024)
            {
                return (size / (1024d * 1024d)).ToString("#,###.## M");
            }
            else
            {
                return (size / (1024d * 1024d * 1024d)).ToString("#,###.## G");
            }
        }
    }

    /// <summary>
    /// This class records the time when it was created and a time-out interval. It provides
    /// a method to check whether the time-out interval has elapsed and another one to check
    /// how much time is left until the interval elapses.
    /// </summary>
    public class TimeOut
    {
        /// Hidden from public use
        private TimeSpan Interval;
        private DateTime StartTime;
        private TimeOut() { }

        /// <summary>
        /// Constructs an instance of the time-out class starting immediately and timing out
        /// after the Interval has elapsed.
        /// </summary>
        public TimeOut(TimeSpan Interval)
        {
            this.Interval = Interval;
            this.StartTime = DateTime.Now;
        }

        /// <summary>
        /// Returns whether the time-out has occurred.
        /// </summary>
        public bool TimedOut
        {
            get { return TimeSpan.Compare(DateTime.Now - StartTime, Interval) >= 0; }
        }

        /// <summary>
        /// Returns how much time is left until the time-out.
        /// </summary>
        public TimeSpan TimeLeft
        {
            get
            {
                TimeSpan ts = (StartTime + Interval) - DateTime.Now;
                return ts < TimeSpan.Zero ? TimeSpan.Zero : ts;
            }
        }
    }

    /// <summary>
    /// SortedDictionaryDT is a special kind of SortedDictionary which is intended to keep
    /// track of events ordered by time. The only difference from the SortedDictionary is
    /// that an attempt to add an event with the same time as an existing entry does not
    /// fail - instead the next available time is used.
    /// </summary>
    /// <typeparam name="TV"></typeparam>
    public class SortedDictionaryDT<TV> : SortedDictionary<DateTime, TV>
    {
        /// <summary>
        /// Adds an element at the specified time. If an element with that time already
        /// exists, the next available time will be used, effectively adding Value just
        /// after the other items with the same time.
        /// </summary>
        public new void Add(DateTime Key, TV Value)
        {
            while (ContainsKey(Key))
                Key.AddTicks(1);
            base.Add(Key, Value);
        }
    }

    /// <summary>
    /// This class can be used to keep track of non-fatal problems which are not reported
    /// to the user directly but can be obtained by the developer.
    /// </summary>
    public static class Fault
    {
        /// <summary>
        /// Represents an entry in the set of recorded faults.
        /// </summary>
        public class FaultEntry
        {
            public DateTime Timestamp;
            public string Message;
            public string Filename;
            public string Method;
            public int LineNumber;
            public Thread Thread;

            public override string ToString()
            {
                return ToString("{time}: {file}[{line}] - fault in {func}. {msg}{thread}");
            }

            public string ToString(string fmt)
            {
                string s = fmt;
                s = s.Replace("{time}", Timestamp.ToShortTimeString());
                s = s.Replace("{file}", Filename);
                s = s.Replace("{line}", LineNumber.ToString());
                s = s.Replace("{func}", Method);
                s = s.Replace("{msg}", Message);
                if (Thread != null)
                    s = s.Replace("{thread}", "(thread:" + Thread.Name + ")");
                return s;
            }
        }

        /// <summary>
        /// The list of all fault entries
        /// 
        /// Multi-threading: if you access the Entries list directly, you should either
        /// ensure that no other thread calls AddMT, or lock the Entries list for the
        /// duration of the processing.
        /// </summary>
        public static List<FaultEntry> Entries = new List<FaultEntry>();

        /// <summary>
        /// Adds a message to the Fault list. The fault entry will contain the specified
        /// message as well as a timestamp and full information about the function
        /// calling Add, including file & line number.
        /// 
        /// Multi-threading: use AddMT instead.
        /// </summary>
        public static void Add(string Message)
        {
            // Skip the stack frame for the current function
            StackFrame sf = new StackFrame(1, true);
            
            // Create the new fault entry
            FaultEntry FE = new FaultEntry();
            FE.Timestamp = DateTime.Now;
            FE.Message = Message;
            FE.Filename = sf.GetFileName();
            FE.Method = sf.GetMethod().Name;
            FE.LineNumber = sf.GetFileLineNumber();
            FE.Thread = null;

            // Add to the list
            Entries.Add(FE);
        }

        /// <summary>
        /// Adds a message to the Fault list. This method can be safely called from
        /// multiple threads. This method will also store a reference to the thread
        /// which invoked it. See also information about Add.
        /// </summary>
        public static void AddMT(string Message)
        {
            // Skip the stack frame for the current function
            StackFrame sf = new StackFrame(1, true);

            // Create the new fault entry
            FaultEntry FE = new FaultEntry();
            FE.Timestamp = DateTime.Now;
            FE.Message = Message;
            FE.Filename = sf.GetFileName();
            FE.Method = sf.GetMethod().Name;
            FE.LineNumber = sf.GetFileLineNumber();
            FE.Thread = Thread.CurrentThread;

            // Add to the list
            lock (Entries)
                Entries.Add(FE);
        }
    }

    /// <summary>
    /// A pair of two values of specified types.
    /// </summary>
    public struct Tuple2<T1, T2>
    {
        public T1 E1;
        public T2 E2;

        public Tuple2(T1 Element1, T2 Element2)
        {
            E1 = Element1;
            E2 = Element2;
        }
    }

    /// <summary>
    /// A class which can enumerate all pairs of items in an IList.
    /// 
    /// Usage example: foreach (Pair<T,T> p in new EnumPairs(TheList)) {...}
    /// </summary>
    /// <typeparam name="T">The type of an item in the IList</typeparam>
    public class EnumPairs<T>
    {
        private IList<T> A;

        private EnumPairs() {}

        public EnumPairs(IList<T> List)
        {
            A = List;
        }

        public IEnumerator<Tuple2<T, T>> GetEnumerator()
        {
            for (int i=0; i<A.Count-1; i++)
                for (int j=i+1; j<A.Count; j++)
                    yield return new Tuple2<T, T>(A[i], A[j]);
        }
    }

    /// <summary>
    /// Helper class for GDI operations
    /// </summary>
    public static class GDI
    {
        /// <summary>
        /// Caches previously used Pens of predefined width and the specified color.
        /// </summary>
        private static Dictionary<Color, Pen> PenCache = new Dictionary<Color, Pen>();

        /// <summary>
        /// Caches previously used Solid Brushes of the specified color.
        /// </summary>
        private static Dictionary<Color, Brush> BrushCache = new Dictionary<Color, Brush>();

        /// <summary>
        /// Returns a pen of the specified color. The pen will be retrieved from the cache
        /// in case it exists; otherwise it will be created and cached.
        /// </summary>
        /// <param name="clr">Color of the pen to be retrieved</param>
        public static Pen GetPen(Color clr)
        {
            if (PenCache.ContainsKey(clr))
                return PenCache[clr];

            Pen p = new Pen(clr, 3);
            PenCache[clr] = p;
            return p;
        }

        /// <summary>
        /// Returns a brush of the specified color. The brush will be retrieved from the cache
        /// in case it exists; otherwise it will be created and cached.
        /// </summary>
        /// <param name="clr">Color of the brush to be retrieved</param>
        public static Brush GetBrush(Color clr)
        {
            if (BrushCache.ContainsKey(clr))
                return BrushCache[clr];

            SolidBrush b = new SolidBrush(clr);
            BrushCache[clr] = b;
            return b;
        }
    }

    /// <summary>
    /// A double-precision rectangle class which supports intersect tests.
    /// </summary>
    public struct RectangleD
    {
        public double X;
        public double Y;
        public double Width;
        public double Height;

        public RectangleD(double X, double Y, double Width, double Height)
        {
            this.X = X;
            this.Y = Y;
            this.Width = Width;
            this.Height = Height;
        }

        public double Left { get { return X; } }
        public double Top { get { return Y; } }
        public double Right { get { return X + Width; } }
        public double Bottom { get { return Y + Height; } }

        public bool IntersectsWith(RectangleD r)
        {
            return ContainsPoint(r.Left,  r.Top) || ContainsPoint(r.Left,  r.Bottom)
                || ContainsPoint(r.Right, r.Top) || ContainsPoint(r.Right, r.Bottom)
                || (r.Left >= Left && r.Right <= Right && r.Top <= Top && r.Bottom >= Bottom)
                || (r.Left <= Left && r.Right >= Right && r.Top >= Top && r.Bottom <= Bottom);
        }

        public bool ContainsPoint(double X, double Y)
        {
            return (X >= Left) && (X <= Right) && (Y >= Top) && (Y <= Bottom);
        }
    }
}
