/// Utils.cs  -  utility functions and classes

using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Threading;
using System.Windows.Forms;
using System.Diagnostics;
using RT.Util.Dialogs;
using System.IO;

namespace RT.Util
{
    /// <summary>
    /// This class offers some generic static functions which are hard to categorize
    /// under any more specific classes.
    /// </summary>
    public static class Ut
    {
        /// <summary>
        /// An application-wide random number generator - use this generator if all you
        /// need is a random number. Create a new generator only if you really need to.
        /// </summary>
        public static Random Rnd = new Random();

        /// <summary>
        /// Compares two arrays with the elements of the specified type for equality.
        /// Arrays are equal if both are null, or if all elements are equal.
        /// </summary>
        public static bool ArraysEqual<T>(T[] Arr1, T[] Arr2) where T: IEquatable<T>
        {
            if (Arr1 == null && Arr2 == null)
                return true;
            else if (Arr1 == null || Arr2 == null)
                return false;
            else if (Arr1.Length != Arr2.Length)
                return false;

            for (int i=0; i<Arr1.Length; i++)
                if (Arr1[i].Equals(Arr2[i]))
                    return false;
            return true;
        }

        /// <summary>
        /// Counts the number of occurrences of string in another string
        /// </summary>
        /// <param name="in_string">Main string</param>
        /// <param name="to_be_counted">String to be counted</param>
        /// <returns>Number of occurrences of to_be_counted</returns>
        public static int CountStrings(string in_string, string to_be_counted)
        {
            int result = -1;
            int last = -1;
            do
            {
                result++;
                last = in_string.IndexOf(to_be_counted, last+1);
            } while (last != -1);
            return result;
        }

        /// <summary>
        /// Converts file size in bytes to a string in bytes, kbytes, Mbytes
        /// or Gbytes accordingly. The suffix appended is kB, MB or GB.
        /// </summary>
        /// <param name="size">Size in bytes</param>
        /// <returns>Converted string</returns>
        public static string SizeToString(long size)
        {
            if (size == 0)
            {
                return "0";
            }
            else if (size < 1024)
            {
                return size.ToString("#,###");
            }
            else if (size < 1024 * 1024)
            {
                return (size / 1024d).ToString("#,###.## kB");
            }
            else if (size < 1024 * 1024 * 1024)
            {
                return (size / (1024d * 1024d)).ToString("#,###.## MB");
            }
            else
            {
                return (size / (1024d * 1024d * 1024d)).ToString("#,###.## GB");
            }
        }

        private static long TicStart = 0;

        /// <summary>
        /// Starts a simple performance timer.
        /// </summary>
        public static void Tic()
        {
            WinAPI.QueryPerformanceCounter(out TicStart);
        }

        /// <summary>
        /// Stops a simple performance timer started by Tic() and returns the
        /// number of seconds elapsed, accurate to the resolution of the system
        /// timer. Note that there exists only a single timer; Toc returns the
        /// time since the very last call to Tic.
        /// </summary>
        public static double Toc()
        {
            long TicStop;
            WinAPI.QueryPerformanceCounter(out TicStop);
            return ((double)(TicStop - TicStart)) / (double)WinAPI.PerformanceFreq;
        }

        #region Paths / directories

        /// <summary>
        /// Stores a copy of the value generated by AppPath. This way AppPath
        /// only needs to generate it once.
        /// </summary>
        private static string CachedAppPath = "";

        /// <summary>
        /// Returns the application path with a directory separator char at the end.
        /// The expression 'Ut.AppPath + "FileName"' yields a valid fully qualified
        /// file name. Supports network paths.
        /// </summary>
        public static string AppPath
        {
            get
            {
                if (CachedAppPath == "")
                {
                    CachedAppPath = Application.ExecutablePath;
                    CachedAppPath = CachedAppPath.Remove(
                        CachedAppPath.LastIndexOf(System.IO.Path.DirectorySeparatorChar) + 1);
                }
                return CachedAppPath;
            }
        }

        /// <summary>
        /// This function returns a fully qualified name for the subpath, relative
        /// to the executable directory. This is for the purist programmers who can't
        /// handle AppPath returning something "invalid" :)
        /// </summary>
        public static string MakeAppSubpath(string subpath)
        {
            return Ut.AppPath + subpath;
        }

        /// <summary>
        /// "Normalises" the path so that it ends with the Directory separator
        /// character. Does not check the path or otherwise guarantee it's
        /// valid.
        /// </summary>
        /// <param name="path">Path to be normalised</param>
        /// <returns>Normalised version of Path</returns>
        public static string NrmPath(string path)
        {
            if (path==null)
                return "";
            else if (path.Length==0)
                return "";
            else if (path[path.Length-1] == Path.DirectorySeparatorChar)
                return path;
            else
                return path + Path.DirectorySeparatorChar;
        }

        /// <summary>
        /// Ensures that no path ends with a back slash except for the root path.
        /// Surely this is a funny path, unlike the N(o)rm(al)Path above...
        /// </summary>
        public static string FunnyPath(string path)
        {
            if (path == null)
                return "";
            else if (path.Length==0)
                return "";
            else if (path.Length==2 && path[1] == ':')
                return path + Path.DirectorySeparatorChar;
            else if (path.Length==3)
                return path;
            else if (path[path.Length-1] == Path.DirectorySeparatorChar)
                return path.Substring(0, path.Length-1);
            else
                return path;
        }

        /// <summary>
        /// Checks whether path refers to a subdirectory inside ref_path.
        /// </summary>
        public static bool IsSubpath(string ref_path, string path)
        {
            string bp = Ut.NrmPath(ref_path.ToUpper());
            string p = Ut.NrmPath(path.ToUpper());

            if (p.Length <= bp.Length)
                return false;

            return p.Substring(0, bp.Length) == bp;
        }

        /// <summary>
        /// Returns the number of sublevels 'path' is away from ref_path.
        /// Positive numbers indicate that path is deeper than ref_path;
        /// negative that it's above ref_path. If neither is a subpath of
        /// the other an exception is thrown.
        /// </summary>
        /// <param name="ref_path">Reference path</param>
        /// <param name="path">Path to be compared</param>
        public static int PathLevelDistance(string ref_path, string path)
        {
            string p1 = Ut.NrmPath(ref_path.ToUpper());
            string p2 = Ut.NrmPath(path.ToUpper());

            if (p1 == p2)
                return 0;

            if (p1.Length<p2.Length)
            {
                if (p2.Substring(0, p1.Length) != p1)
                    throw new Exception();
                p1 = p2.Substring(p1.Length);
                return Ut.CountStrings(p1, Path.DirectorySeparatorChar+"");
            }
            else
            {
                if (p1.Substring(0, p2.Length) != p2)
                    throw new Exception();
                p2 = p1.Substring(p2.Length);
                return -Ut.CountStrings(p2, Path.DirectorySeparatorChar+"");
            }
        }

        #endregion

        #region Internal error

        /// <summary>
        /// Informs the user nicely that an internal error has occurred. Does not
        /// actually terminate the program, so if the problem is not fatal the user
        /// could save their work etc.
        /// </summary>
        public static void InternalError()
        {
            InternalError(null);
        }

        /// <summary>
        /// Informs the user nicely that an internal error has occurred. Does not
        /// actually terminate the program, so if the problem is not fatal the user
        /// could save their work etc.
        /// </summary>
        /// <param name="ErrorCode">Some error code to help the developer pinpoint the problem.</param>
        public static void InternalError(int ErrorCode)
        {
            InternalErrorPrivate(ErrorCode.ToString());
        }

        /// <summary>
        /// Informs the user nicely that an internal error has occurred. Does not
        /// actually terminate the program, so if the problem is not fatal the user
        /// could save their work etc.
        /// </summary>
        /// <param name="ErrorCode">Some error message to help the developer pinpoint the problem.</param>
        public static void InternalError(string ErrorMsg)
        {
            InternalErrorPrivate(ErrorMsg);
        }

        /// <summary>
        /// Raises an internal error. The reason why this is private is so that only
        /// the other InternalError functions can call it. This ensures that the
        /// function can always backtrack exactly 2 stack frames to get to the place
        /// which invoked InternalError.
        /// </summary>
        private static void InternalErrorPrivate(string ErrorMsg)
        {
            string str = "Internal application error has occurred. Please inform the developer.\n";
            if (ErrorMsg != null) str += "\nError message: " + ErrorMsg;
            StackFrame sf = new StackFrame(2, true);
            str += "\nMethod: " + sf.GetMethod();
            if (sf.GetFileLineNumber() != 0)
                // The line number is zero if there is no program database in the
                // application directory (which is the case when a normal user runs it)
                str += "\nFile: " + sf.GetFileName() + "\nLine: " + sf.GetFileLineNumber();

            DlgMessage.ShowError(str, "Internal error", "OK");
        }

        #endregion
    }

    #region ConfirmEvent

    /// <summary>
    /// EventArgs for the ConfirmEventHandler delegate.
    /// </summary>
    public class ConfirmEventArgs : EventArgs
    {
        /// <summary>
        /// Set this to true/false to confirm or cancel the action.ssss
        /// </summary>
        public bool ConfirmOK;
    }

    /// <summary>
    /// A general-purpose event type which lets the caller confirm an action.
    /// </summary>
    public delegate void ConfirmEventHandler(object sender, ConfirmEventArgs e);

    #endregion

}
